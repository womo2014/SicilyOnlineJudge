//1005. 快速求幂
/******************************************************************************** 
我不希望有人直接拿这个代码去提交然后AC，大家都是成年人了，自己把握。 
如果你还没有学到 条件控制语句，循环控制语句，以及数组，那么没有必要看下去了，先去
学好这些语法，假如你学过了，那就耐心看下去吧。 
*********************************************************************************
这道题无法用pow函数，因为这道题的数据最大可以大到100^1000000000，
远远超过c++内置变量所能表示的最大范围。所以主要的方向就是减小运算的规模 
题目给出了两条提示的等式： 
a^4=(a^2)*(a^2);         这条等式提示我们当指数为偶数时，可以把指数分为一半b =（b/2） 
(a*b)%p=((a%p)*(b%p))%p; 这条等式提示可以把相乘的两项拆出来分别取余之后再相乘再取余 
第一条等式运用时会有指数不是偶数的问题，则可以结合第二条等式构造出b=(b-1),b就变成偶数 

思路示例：假设b = 5;则 a^5%p = ( (a^4%p)*(a%p) )%p                            操作#b-1
						 = ( ( (a^2%p)*(a^2%p)%p )*(a%p) )%p                  操作#b/2
						 = ( ( ( (a%p * a%p)*(a%p * a%p) )%p )*(a%p) )%p      操作#b/2
这是从最终结果(a^5%p)运用上述两条等式递推到最初的(a%p)，
如果用递归函数写的话比较好写，也容易考虑 
假如不用递归，那么就得从一开始的(a%p)算到(a^5%p)了
用ret 记录每次的结果 最初就是ret = a%p  ,那么： 
第一步是#b/2,则 ret = (ret*ret)%p
第二步是#b/2,则 ret = ( ret*ret)%p
第三步是#b-1,则 ret = ( ret*a%p)%p   这就是最终结果了
*************************************************************************************
ps:语文学的不好，大家将就着耐心看，看到不懂的语法尽可能自己百度理解 ，如果有错，欢迎
大家指出 

王济锋
2014.10.21 
*************************************************************************************
*/ 

#include <iostream>

using namespace std;

int main()
{
   int a, b, p; // a为底数（2-100），b为指数（0-1000000000），p为取余的数（3-10000） 
   cin >> a >> b >> p;
   a = a % p;// 为了方便，直接把a取模过后的值赋值给a 
   int ret = a;// ret为最终求出来的结果，如果指数为1，则结果就是ret初始化的值 
   
   if ( b > 1 ) //指数大于1 
   {
	   //把b按上述过程逆推回去，并记录逆推过程中所做的变化（#b/2 #b-1） 
	   int record[100]; //开一个记录b变化步骤的数组 
	   int cnt = 0; // 用于取数组下标 ,初始化为0 
	   while ( b != 1 )  // 当b逆推到1时结束循环 
	   {
	      if ( b % 2 == 0 ) //b为偶数 #b/2 的情况，用0来记录 
	      {
	         record[cnt++] = 0; // 相当于record[cnt] = 0;cnt = cnt + 1; 如果不懂百度单目运算符 
	         b /= 2;
	      }
	      else //b为奇数 #b-1 的情况 ，用1来记录
		  {
	         record[cnt++] = 1;
	         b -= 1; // b变为了偶数 
	      }
	   }
	   //一步一步算到最终结果 
	   while ( cnt-- ) //逐渐把cnt递减为0，并使循环执行cnt次
	   {
	      if ( record[cnt] == 0 ) //#b/2 的情况 
	           ret = (ret * ret) % p;
	      else //#b-1 的情况 
	           ret = (ret * a) % p;
	   }
   }
   else if ( b == 0 ) //指数小于1，如果刚好为0，则 结果为1  
      ret = 1;
   
   cout << ret << endl; //输出运算结果 
   return 0;
}  


// 以下是使用递归函数的做法,仅供参考，就不加注释了 
#include <iostream>

using namespace std;
int my_pow_mod(int a, int b, int p);

int main()
{
	int a, b, p;
	cin >> a >> b >> p;
	cout << my_pow_mod(a%p, b, p) << endl;
	return 0;
}

int my_pow_mod(int a, int b, int p )
{
	int ret;
	if ( b == 0 ) 
		ret = 1;
	else if ( b == 1 )
		ret = a;
	else if ( b % 2 == 0 )
	{
		int x = my_pow_mod(a, b/2, p);
		ret = (x * x) % p;
	}
	else
		ret = (my_pow_mod(a, b-1, p) * a) % p;
	
	return ret;
}   
